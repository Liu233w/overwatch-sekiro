/*
code about attack
*/

import "block.del";
import "posture.del";
import "state-mark.del";

class AttackingEvent
{
    public define victim;

    public define directDamage;

    // TODO: let each kind of attacking have their own posture damage
    // can be achieved by adding a multiplier (* the multiplier when hitted in blocking)

    public define directlyHittedPostureMultiplier = 1;

    public AttackingEvent(define victim, define damage)
    {
        this.victim = victim;
        this.directDamage = damage;
    }
}

define playervar attacking = [];

// ----------- doomfist ------------
rule: "doomfist's ability 2: deal 1/2 damage when directly hitted"
Event.OnDamageDealt
Player.Doomfist
if (!IsBlocking(Victim()) && !IsDeflecting(Victim()))
if (IsUsingAbility2(Attacker()))
{
    attacking = Append(attacking, new AttackingEvent(Victim(), EventDamage() / 2));
}

rule: "doomfist's ability 2: hit when blocked, deal 2X posture damage"
Event.OnDamageDealt
Player.Doomfist
if (IsBlocking(Victim()) && !IsDeflecting(Victim()))
if (IsUsingAbility2(Attacker()))
{
    Heal(Victim(), null, EventDamage());
    GainPostureWhenBlocking(Victim(), EventDamage() * 2, Attacker());
}

// ability 2: gain ordinary damage when deflected

rule: "doomfist's primary attack: deal 1/4 damage when directly hitted"
Event.OnDamageDealt
Player.Doomfist
if (!IsBlocking(Victim()) && !IsDeflecting(Victim()))
if (IsOnGround(Victim()))
if (InFiringPrimaryState(Attacker()))
{
    Heal(Victim(), null, EventDamage() * 3 / 4);
    attacking = Append(attacking, new AttackingEvent(Victim(), EventDamage() / 4));
}

rule: "doomfist's primary attack: deal 1/2 posture if blocked"
Event.OnDamageDealt
Player.Doomfist
if (IsBlocking(Victim()) && !IsDeflecting(Victim()))
if (InFiringPrimaryState(Attacker()))
{
    Heal(Victim(), null, EventDamage());
    GainPostureWhenBlocking(Victim(), EventDamage() / 2, Attacker());
}

rule: "doomfist's primary attack: deal 1/4 damage and 2X posture damage when directly hitted on the air"
Event.OnDamageDealt
Player.Doomfist
if (!IsBlocking(Victim()) && !IsDeflecting(Victim()))
if (!IsOnGround(Victim()))
if (InFiringPrimaryState(Attacker()))
{
    Heal(Victim(), null, EventDamage() * 3 / 4);
    AttackingEvent e = new AttackingEvent(Victim(), EventDamage() / 4);
    e.directlyHittedPostureMultiplier = 8; // 1/4 * 8 = 2
    attacking = Append(attacking, e);
}

// ------- doomfist's end ------------

// ================= default damage calculation ==================

rule: "add victim to list after attacking, if the victim is not blocking"
Event.OnDamageDealt
if (!IsBlocking(Victim()) && !IsDeflecting(Victim()))
{
    attacking = Append(attacking, new AttackingEvent(Victim(), EventDamage()));
}

rule: "gain posture if victim is deflecting"
Event.OnDamageDealt
if (IsDeflecting(Victim()))
{
    Heal(Victim(), null, EventDamage());
    GainPostureWhenDeflected(Attacker(), EventDamage(), Victim());
    PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, Victim(), 100);
    PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, Victim(), 100);
    PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, Victim(), 100);
    PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, Victim(), 100);
}

rule: "deal posture if victim is blocking"
Event.OnDamageDealt
if (IsBlocking(Victim()) && !IsDeflecting(Victim()))
{
    Heal(Victim(), null, EventDamage());
    GainPostureWhenBlocking(Victim(), EventDamage(), Attacker());
}

rule: "start checking victim state after a short delay"
Event.OngoingPlayer
if (CountOf(attacking) > 0)
{
    Wait(0.1);

    // cannot hurt more than 3 persons at once, so the loop is acceptable.
    foreach (AttackingEvent e in attacking)
    {
        if (IsDeflecting(e.victim))
        {
            // deflecting
            Heal(e.victim, null, e.directDamage);
            GainPostureWhenDeflected(EventPlayer(), e.directDamage, e.victim);
            PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, e.victim, 100);
            PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, e.victim, 100);
            PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, e.victim, 100);
            PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, e.victim, 100);
        }
        else
        {
            GainPostureByDirectAttack(e.victim, e.directDamage * e.directlyHittedPostureMultiplier, EventPlayer());
        }

        delete(e);
    }

    attacking = [];
}